# 数据库管理人员及数据存储部分的开发人员

定义、首字母缩写词和缩略语 

# 1. 数据库设计：

包括建立数据存储的物理和逻辑空间，定义数据库中的表、视图、索引、字段、存储过程、触发器等对象，以及相互的关系。 

ＳＱＬ编写：指程序员使用 SQL 语句，编制可以执行的操作数据库的代码。由于 SQL 程序的编写和数据库设计紧密相关，因此本规范包括一部分的数据库设计规范。 

# 2. 数据类型规范 

禁止用 SQL 保留字来命名表、视图、字段、索引。数据库的关键字。 

不要设立诸如是否使用的标志字段，统一由数据库删除规则来确定。 标志字段要求提供缺省值。 数字类必须指定缺省值。 

字符型字段的确定。长度固定用 char，不固定用 varchar。

系统序列号必须指定缺省值为 0。 

不要将 Null 与  空串””视为相同。在不同的数据库中对这两者的理解是不相同的。在 Oracle 中空串与 Null 理解一样。如果碰到这种情况统一用 Null。数据库中不允许出现空串 

# 3. 存储过程 

与数据库交互频繁的业务规则，可以考虑用存储过程实现。

每个存储过程代码不能超过 200 行 对重要的计算应用注释说明其功能；  

# 4. 触发器 

避免使用后触发。（SQLServer、Sybase 不支持前触发事件）。如必须使用，需项目经理审批。 

系统序列号的存储统一通过触发器来控制。程序插入赋值时缺省为 0。 不允许动态创建触发器。  

# 5.视图  

使用静态视图，不允许动态创建视图。 

视图中尽量避免包含 ORDER BY 语法，影响效率。

# 6.索引 

为了保证索引具有提高效率的作用，估计记录数不大于 50 的表一律不允许建索引。 

只用于 DISTINCT 或 GROUP BY 子句引用的列，不用建立索引。 对于数据值变化不大的列，比如只有 yes 和 no，那么不要建索引，否则效率降低。

复合索引为多列，同复合主键一样将变化显著的列放到复合索引的首位。 

一个复合索引可包含多达 16 个列(具体可能多数据库会不同)，索引太多则插入数据会变慢，当索引太多的时候，必须权衡查询和插入数据的响应时间是否满足需求。 不允许动态创建索引。  

# 7. 表及外键  

不允许动态创建表、约束、外键。 

# 8. SQL 语句规范 

连接符 OR、IN、AND、运算符号、以及＝、<=、>=等前后加上一个空格；否则容易导致以下类似 

问题。在语句 SELECT a–b FROM table 中， a，b 均为变量。拼写该语句时，如果 a=6， b= -3，则语句 

变为 SELECT 6—3 FROM table。--变为 Sql 的注释，语句报错。 对 SQL 语句加上注释，说明算法、功能； 

多表连接时，必须使用表的别名，并以此来引用列；别名必须是有意义的词。 

供别的文件或函数调用的函数，绝不应使用全局变量交换数据； 禁止使用`SELECT  * FROM `语法，必须标明字段名。 禁止使用`INSERT INTO table_name VALUES(?,?,„„)`语法，统一使用`INSERT INTO table_name (col1,col2,„„) VALUES(?,?,„„)`

如果在语句中有 NOT IN（IN）操作，应考虑用 NOT EXISTS（EXISTS）来重写。 

避免显式或隐含的类型转换。例如在 WHERE 子句中 numeric 型和 int 型的列的比较。 

一行有多列，超过 80 个字符时，基于列对齐原则，采用下行缩进； where 子句书写时，每个条件占一行，语句另起一行时，以保留字或者连接符开始。 

每个事务处理必须有相应的 COMMIT 和 ROLLBACK 对应。                               

# 9. 表别名规范 

要求起别名用表名中有实际含义的单词的首字母。如果在同一个代码块中，单个字母有重复的，可采用首 2 个字母，以此类推。如：表名 tb_user，别名为：u。  

# 10. 函数规范 

不允许动态创建函数。 

只能使用通用 SQL 的函数。如要使用新的函数必须申报，审批后才能使用。 

# 11. 建库规范 

建库脚本文件分类： 

删除表类：包括模块所有表的 DROP 语句。 

表结构类：包括模块所有表的建表语句、主键定义以及 CHECK 约束。还包括数据类型以及规则定义。

外键、视图、函数、索引类（简称外键类）：包括模块所有的外键、视图、索引、函数。包括 DROP 语句。 

触发器、存储过程类： 包括模块的触发器以及存储过程。包括 DROP 语句。 

数据类：包括模块节点以及初始化数据；包括删除数据命令。包括 DELETE 语句。 书写格式： 注释用破折号“--” 

遵循各个数据库 SQL 执行标准。例如，每条 DDL 以及 

# 12. SQL 注释风格 

注释单独成行、放在语句前面； 应对分支条件表达式加注释； 

过长的函数实现，应将其语句按实现的功能分段加以概括性说明； 常量及变量注释时，应注释被保存值的含义(必须)，合法取值的范围(可选) ； 

# 13. 书写优化性能建议 

避免嵌套连接。例如：A = B AND B = C AND C = D 

WHERE 条件中尽量减少使用常量比较，比如，不要用 1=1。 系统可能选择基于规则的优化器，所以将结果集返回数据量小的表作为驱动表（FROM 后边最后一个表）。 

大量的排序操作影响系统性能，所以尽量减少 ORDER BY 和 GROUP BY 排序操作

如必须使用排序操作，请遵循如下规则： 排序尽量建立在有索引的列上。 

如结果集不需唯一，使用 UNION ALL 代替 UNION。 索引的使用。 

尽量避免对索引列进行计算。如对索引列计算较多，请提请系统管理员建立函数索引。 

尽量注意比较值与索引列数据类型的一致性。 对于复合索引，SQL 语句必须使用主索引列 索引中，尽量避免使用 NULL。 

对于索引的比较，尽量避免使用 NOT=（!=） 查询列和排序列与索引列次序保持一致 

尽量避免相同语句由于书写格式的不同，而导致多次语法分析 尽量使用共享的 SQL 语句 

查询的 WHERE 过滤原则，应使过滤记录数最多的条件放在最前面。 任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 

IN、OR 子句常会使用工作表，使索引失效；如果不产生大量重复值，可以考虑把子句拆开；拆开的子句中应该包含索引。  

# 14. 其他经验性规则 

尽量少用嵌套查询。如必须，请用 NOT EXIST 代替 NOT IN 子句。 用多表连接代替 EXISTS 子句。 少用 DISTINCT，用 EXISTS 代替 。

使用 UNION ALL、MINUS、INTERSECT 提高性能 

使用 ROWID 提高检索速度。对 SELECT 得到的单行记录，需进行 DELETE、UPDATE 操作时， 

使用 ROWID 将会使效率大大提高。（需要数据库支持） 使用优化线索机制进行访问路径控制 不建议使用游标，禁止使用隐式游标。 允许使用临时表，但必须显式 DROP。

 